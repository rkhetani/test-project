{
    "docs": [
        {
            "location": "/", 
            "text": "Welcome to MkDocs\n\n\nFor full documentation visit \nmkdocs.org\n.\n\n\nCommands\n\n\n\n\nmkdocs new [dir-name]\n - Create a new project.\n\n\nmkdocs serve\n - Start the live-reloading docs server.\n\n\nmkdocs build\n - Build the documentation site.\n\n\nmkdocs help\n - Print this help message.\n\n\n\n\nProject layout\n\n\nmkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.", 
            "title": "Home"
        }, 
        {
            "location": "/#welcome-to-mkdocs", 
            "text": "For full documentation visit  mkdocs.org .", 
            "title": "Welcome to MkDocs"
        }, 
        {
            "location": "/#commands", 
            "text": "mkdocs new [dir-name]  - Create a new project.  mkdocs serve  - Start the live-reloading docs server.  mkdocs build  - Build the documentation site.  mkdocs help  - Print this help message.", 
            "title": "Commands"
        }, 
        {
            "location": "/#project-layout", 
            "text": "mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.", 
            "title": "Project layout"
        }, 
        {
            "location": "/README/", 
            "text": "Training program description:\n\n\nThe training team at the Harvard Chan Bioinformatics Core provides bioinformatics training through both shorter workshops and longer in-depth courses. Our current workshops and courses are designed to help biologists become comfortable with using tools to analyse high-throughput data. We are slowly beginning to expand this repertoire to include training for researchers with more advanced bioinformatics skills.\n\n\nNo prior NGS or command line expertise is required for our workshops or courses unless explicitly stated.\n\n\nWorkshops\n\n\nIntroduction to Next-Generation Sequencing (NGS) analysis series:\n\n\nThe goal of these workshops (2-3 days) are to enable researchers to design their NGS studies appropriately and perform preliminary data analyses.\n\n\n\n\n\n\n\n\nTraining topic and link to lessons\n\n\nPrerequisites\n\n\nWorkshop Duration\n\n\n\n\n\n\n\n\n\n\nR and ggplot2\n\n\nNone\n\n\n2 days\n\n\n\n\n\n\nRNA-seq data analysis using High-Performance Computing\n\n\nNone\n\n\n2 - 3 days\n\n\n\n\n\n\nR and Differential Gene Expression (DGE) analysis\n\n\nNone\n\n\n3 days\n\n\n\n\n\n\nDifferential Gene Expression (DGE) analysis\n\n\nR and ggplot2\n\n\n1.5 days\n\n\n\n\n\n\nChIP-seq using High-Performance Computing\n\n\nNone\n\n\n3 days\n\n\n\n\n\n\nIdentifying variants in genome/exome sequencing data\n\n\nNone\n\n\nIn development\n\n\n\n\n\n\n\n\nCurrent topics in bioinformatics series:\n\n\nThese short workshops (half-day or less) are designed to allow researchers, who have some familiarity with R or bash, to learn new tools and methods. Only a subset of the short workshops topics are listed and linked below, for the full list please \nclick here\n.\n\n\n\n\n\n\n\n\nTraining topic and link to lessons\n\n\nPrerequisites\n\n\n\n\n\n\n\n\n\n\nIntroduction to R \n Visualizations with ggplot2\n\n\nNone\n\n\n\n\n\n\nPlotting and visualization in R using ggplot2\n\n\nIntro to R\n\n\n\n\n\n\nFunctional analysis of gene lists\n\n\nBeginner R or \nIntroR workshop\n\n\n\n\n\n\nReproducible research using R (Rmarkdown: report generation)\n\n\nBeginner R or \nIntroR workshop\n\n\n\n\n\n\nIntroduction to shell/bash\n\n\nNone\n\n\n\n\n\n\nIntermediate shell/bash\n\n\nIntro to shell\n\n\n\n\n\n\nAccessing public data for genomics\n\n\nIntro to shell\n\n\n\n\n\n\nVersion control using Git and Github\n\n\nIntro to shell\n\n\n\n\n\n\nExploring genomic variants using GEMINI \n(In development)\n\n\nIntro to shell\n\n\n\n\n\n\nIntroduction to tidyverse R packages for data visualization \n(In development)\n\n\nIntro to R\n\n\n\n\n\n\n\n\nIn-Depth Next Generation Sequencing Analysis Course\n\n\nThis intensive course\n runs for between \n8 to 12 days\n and is aimed at bench biologists interested in learning how to \nindependently\n perform NGS data analyses using \nbest practices\n. Topics include:\n\n\n\n\nHigh-performance computing\n\n\nBest practice workflows for NGS data analysis (RNA-seq, ChIP-seq, Variant calling)\n\n\nR for statistical analysis and data visualization\n\n\nFunctional analysis with gene lists\n\n\nAdditional skils and tools for better reproducibility like reports with RMarkdown, version control with Git/Github, etc.\n\n\n\n\nContact us:\n\n\nEmail:\n \nhbctraining@hsph.harvard.edu\n\n\nWebpage:\n \nhttp://bioinformatics.sph.harvard.edu\n\n\nTwitter:\n \n@bioinfocore", 
            "title": "Training materials"
        }, 
        {
            "location": "/README/#training-program-description", 
            "text": "The training team at the Harvard Chan Bioinformatics Core provides bioinformatics training through both shorter workshops and longer in-depth courses. Our current workshops and courses are designed to help biologists become comfortable with using tools to analyse high-throughput data. We are slowly beginning to expand this repertoire to include training for researchers with more advanced bioinformatics skills.  No prior NGS or command line expertise is required for our workshops or courses unless explicitly stated.", 
            "title": "Training program description:"
        }, 
        {
            "location": "/README/#workshops", 
            "text": "", 
            "title": "Workshops"
        }, 
        {
            "location": "/README/#introduction-to-next-generation-sequencing-ngs-analysis-series", 
            "text": "The goal of these workshops (2-3 days) are to enable researchers to design their NGS studies appropriately and perform preliminary data analyses.     Training topic and link to lessons  Prerequisites  Workshop Duration      R and ggplot2  None  2 days    RNA-seq data analysis using High-Performance Computing  None  2 - 3 days    R and Differential Gene Expression (DGE) analysis  None  3 days    Differential Gene Expression (DGE) analysis  R and ggplot2  1.5 days    ChIP-seq using High-Performance Computing  None  3 days    Identifying variants in genome/exome sequencing data  None  In development", 
            "title": "Introduction to Next-Generation Sequencing (NGS) analysis series:"
        }, 
        {
            "location": "/README/#current-topics-in-bioinformatics-series", 
            "text": "These short workshops (half-day or less) are designed to allow researchers, who have some familiarity with R or bash, to learn new tools and methods. Only a subset of the short workshops topics are listed and linked below, for the full list please  click here .     Training topic and link to lessons  Prerequisites      Introduction to R   Visualizations with ggplot2  None    Plotting and visualization in R using ggplot2  Intro to R    Functional analysis of gene lists  Beginner R or  IntroR workshop    Reproducible research using R (Rmarkdown: report generation)  Beginner R or  IntroR workshop    Introduction to shell/bash  None    Intermediate shell/bash  Intro to shell    Accessing public data for genomics  Intro to shell    Version control using Git and Github  Intro to shell    Exploring genomic variants using GEMINI  (In development)  Intro to shell    Introduction to tidyverse R packages for data visualization  (In development)  Intro to R", 
            "title": "Current topics in bioinformatics series:"
        }, 
        {
            "location": "/README/#in-depth-next-generation-sequencing-analysis-course", 
            "text": "This intensive course  runs for between  8 to 12 days  and is aimed at bench biologists interested in learning how to  independently  perform NGS data analyses using  best practices . Topics include:   High-performance computing  Best practice workflows for NGS data analysis (RNA-seq, ChIP-seq, Variant calling)  R for statistical analysis and data visualization  Functional analysis with gene lists  Additional skils and tools for better reproducibility like reports with RMarkdown, version control with Git/Github, etc.", 
            "title": "In-Depth Next Generation Sequencing Analysis Course"
        }, 
        {
            "location": "/README/#contact-us", 
            "text": "Email:   hbctraining@hsph.harvard.edu  Webpage:   http://bioinformatics.sph.harvard.edu  Twitter:   @bioinfocore", 
            "title": "Contact us:"
        }, 
        {
            "location": "/data_viz/", 
            "text": "Approximate time: 75 minutes\n\n\nLearning Objectives\n\n\n\n\nExploring our significant genes using data visualization\n\n\nUsing volcano plots to evaluate relationships between DEG statistics\n\n\nPlotting expression of significant genes using heatmaps\n\n\n\n\nExtracting significant differentially expressed genes\n\n\nWhat we noticed is that the FDR threshold on it's own doesn't appear to be reducing the number of significant genes. With large significant gene lists it can be hard to extract meaningful biological relevance. To help increase stringency, one can also \nadd a fold change threshold\n. \nThe \nsummary()\n function doesn't have an argument for fold change threshold\n\n\n\n\nNOTE:\n the \nresults()\n function does have an option to add a fold change threshold and subset the data this way. Take a look at the help manual using \n?results\n and see what argument would be required. However, rather than subsetting the results, we want to return the whole dataset and simply identify which genes meet our criteria. \n\n\n\n\nLet's first create variables that contain our threshold criteria:\n\n\n### Set thresholds\npadj.cutoff \n- 0.05\nlfc.cutoff \n- 0.58\n\n\n\n\nThe \nlfc.cutoff\n is set to 0.58; remember that we are working with log2 fold changes so this translates to an actual fold change of 1.5 which is pretty reasonable. Let's create vector that helps us identify the genes that meet our criteria:\n\n\nthreshold \n- res_tableOE$padj \n padj.cutoff \n abs(res_tableOE$log2FoldChange) \n lfc.cutoff\n\n\n\n\nWe now have a logical vector of values that has a length which is equal to the total number of genes in the dataset. The elements that have a \nTRUE\n value correspond to genes that meet the criteria (and \nFALSE\n means it fails). \nHow many genes are differentially expressed in the Overexpression compared to Control, given our criteria specified above?\n Does this reduce our results? \n\n\nlength(which(threshold))\n\n\n\n\nTo add this vector to our results table we can use the \n$\n notation to create the column on the left hand side of the assignment operator, and the assign the vector to it instead of using \ncbind()\n:\n\n\nres_tableOE$threshold \n- threshold                \n\n\n\n\nNow we can easily subset the results table to only include those that are significant using the \nsubset()\n function:\n\n\nsigOE \n- data.frame(subset(res_tableOE, threshold==TRUE))\n\n\n\n\nUsing the same thresholds as above (\npadj.cutoff \n 0.05\n and \nlfc.cutoff = 0.58\n), create a threshold vector to report the number of genes that are up- and down-regulated in Mov10_knockdown compared to control.\n\n\nthreshold_KD \n- res_tableKD$padj \n padj.cutoff \n abs(res_tableKD$log2FoldChange) \n lfc.cutoff\n\n\n\n\nTake this new threshold vector and add it as a new column called \nthreshold\n to the \nres_tableKD\n which contains a logical vector denoting genes as being differentially expressed or not. \nHow many genes are differentially expressed in the Knockdown compared to Control?\n Subset the data to keep only the significant genes.\n\n\nres_tableKD$threshold \n- threshold_KD\n\nsigKD \n- data.frame(subset(res_tableKD, threshold==TRUE))\n\n\n\n\nVisualizing the results\n\n\nWhen we are working with large amounts of data it can be useful to display that information graphically to gain more insight. Visualization deserves an entire course of its own, but during this lesson we will get you started with some basic and more advanced plots commonly used when exploring differential gene expression data.\n\n\nLet's start by loading a few libraries:\n\n\n# Load libraries\nlibrary(DESeq2)\nlibrary(reshape)\nlibrary(ggplot2)\nlibrary(ggrepel)\nlibrary(DEGreport)\nlibrary(RColorBrewer)\nlibrary(pheatmap)\n\n\n\n\nPlotting signicant DE genes\n\n\nOne way to visualize results would be to simply plot the expression data for a handful of genes. We could do that by picking out specific genes of interest or selecting a range of genes:\n\n\nUsing DESeq2 \nplotCounts()\n to plot expression of a single gene\n\n\nTo pick out a specific gene of interest to plot, for example Mov10, we can use the \nplotCounts()\n from DESeq2:\n\n\n# Plot expression for single gene\nplotCounts(dds, gene=\nMOV10\n, intgroup=\nsampletype\n) \n\n\n\n\n\n\nThis function only allows for plotting the counts of a single gene at a time.\n \n\n\nUsing ggplot2 to plot expression of a single gene\n\n\nIf you wish to change the appearance of this plot, we can save the output of \nplotCounts()\n to a variable specifying the \nreturnData=TRUE\n argument, then use \nggplot()\n:\n\n\n# Save plotcounts to variable\nd \n- plotCounts(dds, gene=\nMOV10\n, intgroup=\nsampletype\n, returnData=TRUE)\n\n# Adding samplenames to data frame\nd$name \n- rownames(d)\n\n# Plotting the MOV10 normalized counts\nggplot(d, aes(x=sampletype, y=count, color=sampletype)) + \n  geom_point(position=position_jitter(w=0.1,h=0)) +\n  geom_text_repel(aes(label = name)) + \n  theme_bw() +\n  ggtitle(\nMOV10\n) +\n  theme(plot.title=element_text(hjust=0.5))\n\n\n\n\n\n\nNote that in the plot below (code above), we are using \ngeom_text_repel()\n from the 'ggrepel' R package to label our individual points on the plot.\n\n\n\n\n\n\nUsing \nggplot2\n to plot multiple genes (e.g. top 20)\n\n\nOften it is helpful to check the expression of multiple genes of interest at the same time. While this isn't easily done using the \nplotCounts()\n function, we can use \nggplot()\n to do this after performing some data wrangling.\n\n\nWe are going to plot the normalized count values for the \ntop 20 differentially expressed genes (by padj values)\n. \n\n\nTo do this, we first need to determine the gene names of our top 20 genes by ordering our significant results and extracting the top 20 genes:\n\n\n## Order significant results by padj values\nsigOE_ordered \n- sigOE[order(sigOE$padj), ]\ntop20_sigOE_genes \n- rownames(sigOE_ordered[1:20, ])\n\n\n\n\nThen, we can extract the normalized count values for these top 20 genes:\n\n\n## normalized counts for top 20 significant genes\nnormalized_counts \n- counts(dds, normalized=T)\ntop20_sigOE_norm \n- normalized_counts[top20_sigOE_genes, ]\n\n\n\n\nNow that we have the normalized counts for each of the top 20 genes for all 8 samples, to plot using \nggplot()\n, we need to gather the counts for all samples into a single column to allow us to give ggplot the one column with the values we want it to plot.\n\n\nThe \nmelt()\n function in the \nreshape\n R package will perform this operation and will output the normalized counts for all genes for \nMov10_oe_1\n listed in the first 20 rows, followed by the normalized counts for \nMov10_oe_2\n in the next 20 rows, so on and so forth.\n\n\n\n\n## use melt to modify the format of the data frame\nmelted_top20_sigOE \n- data.frame(melt(top20_sigOE_norm))\n\n## check the column header in the \nmelted\n data frame\nView(melted_top20_sigOE)\n\n## add column names that make sense\ncolnames(melted_top20_sigOE) \n- c(\ngene\n, \nsamplename\n, \nnormalized_counts\n)\n\n\n\n\nNow, if we want our counts colored by sample group, then we need to combine the metadata information with the melted normalized counts data into the same data frame for input to \nggplot()\n:\n\n\n## add metadata to \nmelted\n dataframe\nmeta$samplename \n- rownames(meta)\n\nmelted_top20_sigOE \n- merge(melted_top20_sigOE, meta)\n\n\n\n\nThe \nmerge()\n will merge 2 data frames with respect to the \"samplename\" column, i.e. a column with the same colname in both data frames.\n\n\nNow that we have a data frame in a format that can be utilised by ggplot easily, let's plot! \n\n\n## plot using ggplot2\nggplot(melted_top20_sigOE) +\n        geom_point(aes(x = gene, y = normalized_counts, color = sampletype)) +\n        scale_y_log10() +\n        xlab(\nGenes\n) +\n        ylab(\nNormalized Counts\n) +\n        ggtitle(\nTop 20 Significant DE Genes\n) +\n        theme_bw() +\n    theme(axis.text.x = element_text(angle = 45, hjust = 1)) +\n    theme(plot.title=element_text(hjust=0.5))\n\n\n\n\n\n\nHeatmap\n\n\nIn addition to plotting subsets, we could also extract the normalized values of \nall\n the significant genes and plot a heatmap of their expression using \npheatmap()\n.\n\n\n### Extract normalized expression for significant genes\nnorm_OEsig \n- normalized_counts[rownames(sigOE),]\n\n\n\n\nNow let's draw the heatmap using \npheatmap\n:\n\n\n### Annotate our heatmap (optional)\nannotation \n- data.frame(sampletype=meta[,'sampletype'], \n                     row.names=rownames(meta))\n\n### Set a color palette\nheat.colors \n- brewer.pal(6, \nYlOrRd\n)\n\n### Run pheatmap\npheatmap(norm_OEsig, color = heat.colors, cluster_rows = T, show_rownames=F,\nannotation= annotation, border_color=NA, fontsize = 10, scale=\nrow\n,\n     fontsize_row = 10, height=20)\n\n\n\n\n\n\n\n\nNOTE:\n There are several additional arguments we have included in the function for aesthetics. One important one is \nscale=\"row\"\n, in which Z-scores are plotted, rather than the actual normalized count value. Z-scores are computed on a gene-by-gene basis by subtracting the mean and then dividing by the standard deviation. The Z-scores are computed \nafter the clustering\n, so that it only affects the graphical aesthetics and the color visualization is improved.\n\n\n\n\nVolcano plot\n\n\nHeatmaps are great to look at the expression levels of a fairly large number of genes, but for more of a global view we can use the volcano plot. Here, the log transformed adjusted p-values are plotted on the y-axis and log2 fold change values on the x-axis. There is no built-in function for the drawing volcano plots in DESeq2, just as there is none for heatmaps, but we can easily draw it using \nggplot2\n. \n\n\nTo generate a volcano plot, we have a column in our results data indicating whether or not the gene is considered differentially expressed based on p-adjusted and log2 foldchange values. First, we need to convert our results object into a data frame.\n\n\nresOE_df \n- data.frame(res_tableOE)\n\nView(resOE_df)\n\n\n\n\nSince we have the \nthreshold\n column,  we can start plotting. The \ngeom_point\n object is most applicable, as this is essentially a scatter plot:\n\n\n# Volcano plot\nggplot(resOE_df) +\n  geom_point(aes(x=log2FoldChange, y=-log10(padj), colour=threshold)) +\n  ggtitle(\nMov10 overexpression\n) +\n  xlab(\nlog2 fold change\n) + \n  ylab(\n-log10 adjusted p-value\n) +\n  theme(legend.position = \nnone\n,\n        plot.title = element_text(size = rel(1.5), hjust = 0.5),\n        axis.title = element_text(size = rel(1.25)))  \n\n\n\n\n \n\n\nThis is a great way to get an overall picture of what is going on, but what if we also wanted to know where the top 10 genes (lowest padj) in our DE list are located on this plot? We could label those dots with the gene name on the Volcano plot using \ngeom_text_repel()\n.\n\n\nTo make this work we have to take the following 3 steps:\n(Step 1) Create a new data frame sorted or ordered by padj\n(Step 2) Indicate in the data frame which genes we want to label by adding a logical vector to it, wherein \"TRUE\" = genes we want to label.\n\n\nresOE_df_ordered \n- resOE_df[order(resOE_df$padj), ] \n\nresOE_df_ordered$genelabels \n- rownames(resOE_df_ordered) %in% rownames(resOE_df_ordered[1:10,])\n\nView(resOE_df_ordered)\n\n\n\n\n(Step 3) Finally, we need to add the \ngeom_text_repel()\n layer to the ggplot code we used before, and let it know which genes we want labelled. \n\n\nggplot(resOE_df_ordered) +\n  geom_point(aes(x = log2FoldChange, y = -log10(padj), colour = threshold)) +\n  geom_text_repel(aes(x = log2FoldChange, y = -log10(padj), label = ifelse(genelabels == T, rownames(resOE_df_ordered),\n))) +\n  ggtitle(\nMov10 overexpression\n) +\n  xlab(\nlog2 fold change\n) + \n  ylab(\n-log10 adjusted p-value\n) +\n  theme(legend.position = \nnone\n,\n        plot.title = element_text(size = rel(1.5), hjust = 0.5),\n        axis.title = element_text(size = rel(1.25))) \n\n\n\n\n \n\n\nThe \nifelse()\n function is a simple function that outputs a vector if a certain condition is T. In the above example, it checks if the value in the \nresOE_df_ordered$genelevel\n column is TRUE, in which case it will output the row name for that row (\nrownames(resOE_df_ordered)\n). If the value in the genelevel column is FALSE it will output nothing (\n\"\"\n). This is good way to inform \ngeom_point()\n about genes we want labeled.\n\n\n\n\nNOTE:\n The package 'DEGreport' can make the top20 genes and the volcano plots generated above by writing a few lines of simple code. While you can customize the plots above, you may be interested in using the easier code. Below are examples for code to create these plots:\n\n\nDEGreport::degPlot(dds = dds, res = res, n=20, xs=\ntype\n, group = \ncondition\n)\n\nDEGreport::degVolcano(\n    as.data.frame(res[,c(\nlog2FoldChange\n,\npadj\n)]), # table - 2 columns\n    plot_text=as.data.frame(res[1:10,c(\nlog2FoldChange\n,\npadj\n,\nid\n)])) # table to add names\n\n# Available in the newer version for R 3.4\nDEGreport::degPlotWide(dds = dds, genes = row.names(res)[1:5], group = \ncondition\n)\n\n\n\n\n\n\nThis lesson has been developed by members of the teaching team at the \nHarvard Chan Bioinformatics Core (HBC)\n. These are open access materials distributed under the terms of the \nCreative Commons Attribution license\n (CC BY 4.0), which permits unrestricted use, distribution, and reproduction in any medium, provided the original author and source are credited.\n\n\n\n\nMaterials and hands-on activities were adapted from \nRNA-seq workflow\n on the Bioconductor website", 
            "title": "Data Visualization"
        }, 
        {
            "location": "/data_viz/#learning-objectives", 
            "text": "Exploring our significant genes using data visualization  Using volcano plots to evaluate relationships between DEG statistics  Plotting expression of significant genes using heatmaps", 
            "title": "Learning Objectives"
        }, 
        {
            "location": "/data_viz/#extracting-significant-differentially-expressed-genes", 
            "text": "What we noticed is that the FDR threshold on it's own doesn't appear to be reducing the number of significant genes. With large significant gene lists it can be hard to extract meaningful biological relevance. To help increase stringency, one can also  add a fold change threshold .  The  summary()  function doesn't have an argument for fold change threshold   NOTE:  the  results()  function does have an option to add a fold change threshold and subset the data this way. Take a look at the help manual using  ?results  and see what argument would be required. However, rather than subsetting the results, we want to return the whole dataset and simply identify which genes meet our criteria.    Let's first create variables that contain our threshold criteria:  ### Set thresholds\npadj.cutoff  - 0.05\nlfc.cutoff  - 0.58  The  lfc.cutoff  is set to 0.58; remember that we are working with log2 fold changes so this translates to an actual fold change of 1.5 which is pretty reasonable. Let's create vector that helps us identify the genes that meet our criteria:  threshold  - res_tableOE$padj   padj.cutoff   abs(res_tableOE$log2FoldChange)   lfc.cutoff  We now have a logical vector of values that has a length which is equal to the total number of genes in the dataset. The elements that have a  TRUE  value correspond to genes that meet the criteria (and  FALSE  means it fails).  How many genes are differentially expressed in the Overexpression compared to Control, given our criteria specified above?  Does this reduce our results?   length(which(threshold))  To add this vector to our results table we can use the  $  notation to create the column on the left hand side of the assignment operator, and the assign the vector to it instead of using  cbind() :  res_tableOE$threshold  - threshold                  Now we can easily subset the results table to only include those that are significant using the  subset()  function:  sigOE  - data.frame(subset(res_tableOE, threshold==TRUE))  Using the same thresholds as above ( padj.cutoff   0.05  and  lfc.cutoff = 0.58 ), create a threshold vector to report the number of genes that are up- and down-regulated in Mov10_knockdown compared to control.  threshold_KD  - res_tableKD$padj   padj.cutoff   abs(res_tableKD$log2FoldChange)   lfc.cutoff  Take this new threshold vector and add it as a new column called  threshold  to the  res_tableKD  which contains a logical vector denoting genes as being differentially expressed or not.  How many genes are differentially expressed in the Knockdown compared to Control?  Subset the data to keep only the significant genes.  res_tableKD$threshold  - threshold_KD\n\nsigKD  - data.frame(subset(res_tableKD, threshold==TRUE))", 
            "title": "Extracting significant differentially expressed genes"
        }, 
        {
            "location": "/data_viz/#visualizing-the-results", 
            "text": "When we are working with large amounts of data it can be useful to display that information graphically to gain more insight. Visualization deserves an entire course of its own, but during this lesson we will get you started with some basic and more advanced plots commonly used when exploring differential gene expression data.  Let's start by loading a few libraries:  # Load libraries\nlibrary(DESeq2)\nlibrary(reshape)\nlibrary(ggplot2)\nlibrary(ggrepel)\nlibrary(DEGreport)\nlibrary(RColorBrewer)\nlibrary(pheatmap)", 
            "title": "Visualizing the results"
        }, 
        {
            "location": "/data_viz/#plotting-signicant-de-genes", 
            "text": "One way to visualize results would be to simply plot the expression data for a handful of genes. We could do that by picking out specific genes of interest or selecting a range of genes:", 
            "title": "Plotting signicant DE genes"
        }, 
        {
            "location": "/data_viz/#using-deseq2-plotcounts-to-plot-expression-of-a-single-gene", 
            "text": "To pick out a specific gene of interest to plot, for example Mov10, we can use the  plotCounts()  from DESeq2:  # Plot expression for single gene\nplotCounts(dds, gene= MOV10 , intgroup= sampletype )    This function only allows for plotting the counts of a single gene at a time.", 
            "title": "Using DESeq2 plotCounts() to plot expression of a single gene"
        }, 
        {
            "location": "/data_viz/#using-ggplot2-to-plot-expression-of-a-single-gene", 
            "text": "If you wish to change the appearance of this plot, we can save the output of  plotCounts()  to a variable specifying the  returnData=TRUE  argument, then use  ggplot() :  # Save plotcounts to variable\nd  - plotCounts(dds, gene= MOV10 , intgroup= sampletype , returnData=TRUE)\n\n# Adding samplenames to data frame\nd$name  - rownames(d)\n\n# Plotting the MOV10 normalized counts\nggplot(d, aes(x=sampletype, y=count, color=sampletype)) + \n  geom_point(position=position_jitter(w=0.1,h=0)) +\n  geom_text_repel(aes(label = name)) + \n  theme_bw() +\n  ggtitle( MOV10 ) +\n  theme(plot.title=element_text(hjust=0.5))   Note that in the plot below (code above), we are using  geom_text_repel()  from the 'ggrepel' R package to label our individual points on the plot.", 
            "title": "Using ggplot2 to plot expression of a single gene"
        }, 
        {
            "location": "/data_viz/#using-ggplot2-to-plot-multiple-genes-eg-top-20", 
            "text": "Often it is helpful to check the expression of multiple genes of interest at the same time. While this isn't easily done using the  plotCounts()  function, we can use  ggplot()  to do this after performing some data wrangling.  We are going to plot the normalized count values for the  top 20 differentially expressed genes (by padj values) .   To do this, we first need to determine the gene names of our top 20 genes by ordering our significant results and extracting the top 20 genes:  ## Order significant results by padj values\nsigOE_ordered  - sigOE[order(sigOE$padj), ]\ntop20_sigOE_genes  - rownames(sigOE_ordered[1:20, ])  Then, we can extract the normalized count values for these top 20 genes:  ## normalized counts for top 20 significant genes\nnormalized_counts  - counts(dds, normalized=T)\ntop20_sigOE_norm  - normalized_counts[top20_sigOE_genes, ]  Now that we have the normalized counts for each of the top 20 genes for all 8 samples, to plot using  ggplot() , we need to gather the counts for all samples into a single column to allow us to give ggplot the one column with the values we want it to plot.  The  melt()  function in the  reshape  R package will perform this operation and will output the normalized counts for all genes for  Mov10_oe_1  listed in the first 20 rows, followed by the normalized counts for  Mov10_oe_2  in the next 20 rows, so on and so forth.   ## use melt to modify the format of the data frame\nmelted_top20_sigOE  - data.frame(melt(top20_sigOE_norm))\n\n## check the column header in the  melted  data frame\nView(melted_top20_sigOE)\n\n## add column names that make sense\ncolnames(melted_top20_sigOE)  - c( gene ,  samplename ,  normalized_counts )  Now, if we want our counts colored by sample group, then we need to combine the metadata information with the melted normalized counts data into the same data frame for input to  ggplot() :  ## add metadata to  melted  dataframe\nmeta$samplename  - rownames(meta)\n\nmelted_top20_sigOE  - merge(melted_top20_sigOE, meta)  The  merge()  will merge 2 data frames with respect to the \"samplename\" column, i.e. a column with the same colname in both data frames.  Now that we have a data frame in a format that can be utilised by ggplot easily, let's plot!   ## plot using ggplot2\nggplot(melted_top20_sigOE) +\n        geom_point(aes(x = gene, y = normalized_counts, color = sampletype)) +\n        scale_y_log10() +\n        xlab( Genes ) +\n        ylab( Normalized Counts ) +\n        ggtitle( Top 20 Significant DE Genes ) +\n        theme_bw() +\n    theme(axis.text.x = element_text(angle = 45, hjust = 1)) +\n    theme(plot.title=element_text(hjust=0.5))", 
            "title": "Using ggplot2 to plot multiple genes (e.g. top 20)"
        }, 
        {
            "location": "/data_viz/#heatmap", 
            "text": "In addition to plotting subsets, we could also extract the normalized values of  all  the significant genes and plot a heatmap of their expression using  pheatmap() .  ### Extract normalized expression for significant genes\nnorm_OEsig  - normalized_counts[rownames(sigOE),]  Now let's draw the heatmap using  pheatmap :  ### Annotate our heatmap (optional)\nannotation  - data.frame(sampletype=meta[,'sampletype'], \n                     row.names=rownames(meta))\n\n### Set a color palette\nheat.colors  - brewer.pal(6,  YlOrRd )\n\n### Run pheatmap\npheatmap(norm_OEsig, color = heat.colors, cluster_rows = T, show_rownames=F,\nannotation= annotation, border_color=NA, fontsize = 10, scale= row ,\n     fontsize_row = 10, height=20)    NOTE:  There are several additional arguments we have included in the function for aesthetics. One important one is  scale=\"row\" , in which Z-scores are plotted, rather than the actual normalized count value. Z-scores are computed on a gene-by-gene basis by subtracting the mean and then dividing by the standard deviation. The Z-scores are computed  after the clustering , so that it only affects the graphical aesthetics and the color visualization is improved.", 
            "title": "Heatmap"
        }, 
        {
            "location": "/data_viz/#volcano-plot", 
            "text": "Heatmaps are great to look at the expression levels of a fairly large number of genes, but for more of a global view we can use the volcano plot. Here, the log transformed adjusted p-values are plotted on the y-axis and log2 fold change values on the x-axis. There is no built-in function for the drawing volcano plots in DESeq2, just as there is none for heatmaps, but we can easily draw it using  ggplot2 .   To generate a volcano plot, we have a column in our results data indicating whether or not the gene is considered differentially expressed based on p-adjusted and log2 foldchange values. First, we need to convert our results object into a data frame.  resOE_df  - data.frame(res_tableOE)\n\nView(resOE_df)  Since we have the  threshold  column,  we can start plotting. The  geom_point  object is most applicable, as this is essentially a scatter plot:  # Volcano plot\nggplot(resOE_df) +\n  geom_point(aes(x=log2FoldChange, y=-log10(padj), colour=threshold)) +\n  ggtitle( Mov10 overexpression ) +\n  xlab( log2 fold change ) + \n  ylab( -log10 adjusted p-value ) +\n  theme(legend.position =  none ,\n        plot.title = element_text(size = rel(1.5), hjust = 0.5),\n        axis.title = element_text(size = rel(1.25)))       This is a great way to get an overall picture of what is going on, but what if we also wanted to know where the top 10 genes (lowest padj) in our DE list are located on this plot? We could label those dots with the gene name on the Volcano plot using  geom_text_repel() .  To make this work we have to take the following 3 steps:\n(Step 1) Create a new data frame sorted or ordered by padj\n(Step 2) Indicate in the data frame which genes we want to label by adding a logical vector to it, wherein \"TRUE\" = genes we want to label.  resOE_df_ordered  - resOE_df[order(resOE_df$padj), ] \n\nresOE_df_ordered$genelabels  - rownames(resOE_df_ordered) %in% rownames(resOE_df_ordered[1:10,])\n\nView(resOE_df_ordered)  (Step 3) Finally, we need to add the  geom_text_repel()  layer to the ggplot code we used before, and let it know which genes we want labelled.   ggplot(resOE_df_ordered) +\n  geom_point(aes(x = log2FoldChange, y = -log10(padj), colour = threshold)) +\n  geom_text_repel(aes(x = log2FoldChange, y = -log10(padj), label = ifelse(genelabels == T, rownames(resOE_df_ordered), ))) +\n  ggtitle( Mov10 overexpression ) +\n  xlab( log2 fold change ) + \n  ylab( -log10 adjusted p-value ) +\n  theme(legend.position =  none ,\n        plot.title = element_text(size = rel(1.5), hjust = 0.5),\n        axis.title = element_text(size = rel(1.25)))      The  ifelse()  function is a simple function that outputs a vector if a certain condition is T. In the above example, it checks if the value in the  resOE_df_ordered$genelevel  column is TRUE, in which case it will output the row name for that row ( rownames(resOE_df_ordered) ). If the value in the genelevel column is FALSE it will output nothing ( \"\" ). This is good way to inform  geom_point()  about genes we want labeled.   NOTE:  The package 'DEGreport' can make the top20 genes and the volcano plots generated above by writing a few lines of simple code. While you can customize the plots above, you may be interested in using the easier code. Below are examples for code to create these plots:  DEGreport::degPlot(dds = dds, res = res, n=20, xs= type , group =  condition )\n\nDEGreport::degVolcano(\n    as.data.frame(res[,c( log2FoldChange , padj )]), # table - 2 columns\n    plot_text=as.data.frame(res[1:10,c( log2FoldChange , padj , id )])) # table to add names\n\n# Available in the newer version for R 3.4\nDEGreport::degPlotWide(dds = dds, genes = row.names(res)[1:5], group =  condition )   This lesson has been developed by members of the teaching team at the  Harvard Chan Bioinformatics Core (HBC) . These are open access materials distributed under the terms of the  Creative Commons Attribution license  (CC BY 4.0), which permits unrestricted use, distribution, and reproduction in any medium, provided the original author and source are credited.   Materials and hands-on activities were adapted from  RNA-seq workflow  on the Bioconductor website", 
            "title": "Volcano plot"
        }
    ]
}